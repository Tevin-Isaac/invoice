// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.8.25;

import "@safe-global/safe-contracts/contracts/proxies/SafeProxy.sol";
import "@safe-global/safe-contracts/contracts/Safe.sol";
import "../Proxy.sol";
import "./BitcoinSafeOwner.sol";

/// @title OrangeKitSafeFactory
/// @notice The OrangeKitSafeFactory is the central deployer of the OrangeKit
///         responsible for deploying two contracts: a proxy for the Safe and
///         a proxy for the BitcoinSafeOwner which will be the owner of the
///         Safe. Proxies are deployed using CREATE2 and the addresses of the
///         contracts can be deterministically obtained based on the Ethereum
///         address derived from the public key used for signing.
///         The BitcoinSafeOwner is ERC-1271 compatible contract capable of
///         validating Bitcoin signatures.
contract OrangeKitSafeFactory {
    // Singleton always has to be the first declared variable to ensure the same
    // location as in the Proxy contract. It should also always be ensured the
    // address is stored alone (uses a full word). We add a one word gap to be
    // absolutely sure about it, no matter what fields will come next.
    // slither-disable-start constable-states
    // slither-disable-start unused-state
    address internal singleton;
    bytes32 internal __gap;
    // slither-disable-end constable-states
    // slither-disable-end unused-state

    // The state variables are already initialized in the proxy contract
    // storage. Also, they can not be declared as constants or immutables
    // because they would be inlined and do not have the storage slot reserved.
    // slither-disable-start uninitialized-state
    // slither-disable-start constable-states
    // slither-disable-start immutable-states
    address public safeSingleton;
    address public safeOwnerSingleton;

    address public emergencyGovernance;

    address public owner;

    bool public initialized;
    // slither-disable-end uninitialized-state
    // slither-disable-end constable-states
    // slither-disable-end immutable-states

    event SingletonUpgraded(address oldSingleton, address newSingleton);
    event OwnershipTransferred(address previousOwner, address newOwner);
    event SafeDeployed(
        address indexed safe,
        address indexed bitcoinSafeOwner,
        bytes20 indexed truncatedBitcoinAddress
    );

    error InvalidSingletonAddress(address singleton);
    error InvalidEmergencyGovernanceAddress(address addr);
    error InvalidTruncatedBitcoinAddress();
    error AlreadyInitialized();
    error NotAuthorized();
    error SingletonAlreadyUpgraded();
    error InvalidNewSingletonAddress();
    error InvalidUpgradeInitData();
    error InvalidNewOwnerAddress();

    // v1.0.0-beta.3
    error InvalidNewSafeOwnerSingletonAddress();
    error SafeOwnerSingletonAlreadyUpgraded();
    event SafeOwnerSingletonUpgraded(
        address oldSingleton,
        address newSingleton
    );

    modifier onlyOwner() {
        if (msg.sender != owner) {
            revert NotAuthorized();
        }
        _;
    }

    constructor() {
        // Prevent singleton contract initialization.
        initialized = true;
    }

    /// @notice Initializes the contract.
    /// @dev This function does nothing. All state has been already initialized
    ///      in the previous version. The `upgradeSingleton` logic requires
    ///      to call the initialization function so we leave it empty.
    function initialize() external {
        if (msg.sender != address(this)) {
            // Not strictly necessary but want to avoid fake initialization
            // calls from third parties.
            revert NotAuthorized();
        }
    }

    /// @dev Allows to retrieve the creation code used for the SafeProxy
    ///      deployment. With this it is easily possible to calculate predicted
    ///      address.
    function safeProxyCreationCode() public pure returns (bytes memory) {
        return type(SafeProxy).creationCode;
    }

    /// @dev Allows to retrieve the creation code used for the BitcoinSafeOwner
    ///      proxy deployment. With this it is easily possible to calculate
    ///      predicted address.
    function bitcoinSafeOwnerProxyCreationCode()
        public
        pure
        returns (bytes memory)
    {
        return type(Proxy).creationCode;
    }

    /// @notice Deploys two proxy contracts: Safe proxy and BitcoinSafeOwner
    ///         proxy being a single owner of the deployed Safe. The proxies use
    ///         an implementation code of the two singletons the deployer is
    ///         pointing to. The address of both proxies can be obtained
    ///         deterministically based on the Ethereum address derived from the
    ///         public key used for signing.
    /// @param truncatedBitcoinAddress The main part of a decoded Bitcoin address
    ///        used for BitcoinSafeOwner initialization.
    function deploySafe(
        bytes20 truncatedBitcoinAddress
    ) external returns (SafeProxy safe, Proxy bitcoinSafeOwner) {
        if (truncatedBitcoinAddress == bytes20(0)) {
            revert InvalidTruncatedBitcoinAddress();
        }

        bytes32 salt = keccak256(abi.encodePacked(truncatedBitcoinAddress));

        bitcoinSafeOwner = deployBitcoinSafeOwnerProxy(
            truncatedBitcoinAddress,
            salt
        );
        safe = deploySafeProxy(address(bitcoinSafeOwner), salt);

        emit SafeDeployed(
            address(safe),
            address(bitcoinSafeOwner),
            truncatedBitcoinAddress
        );
    }

    /// @notice Predicts the addresses of the Safe proxy and the BitcoinSafeOwner
    ///         proxy before deployment.
    /// @dev This function calculates the addresses based on the CREATE2 opcode,
    ///      allowing the determination of the addresses before actual deployment.
    /// @param truncatedBitcoinAddress The main part of a decoded Bitcoin address
    ///        used for BitcoinSafeOwner initialization.
    /// @return safe The predicted address of the Safe proxy.
    /// @return bitcoinSafeOwner The predicted address of the BitcoinSafeOwner
    ///         proxy.
    function predictAddresses(
        bytes20 truncatedBitcoinAddress
    ) external view returns (address safe, address bitcoinSafeOwner) {
        bytes32 salt = keccak256(abi.encodePacked(truncatedBitcoinAddress));

        safe = predictSafeAddress(salt);
        bitcoinSafeOwner = predictBitcoinSafeOwnerAddress(salt);
    }

    /// @notice Upgrades the singleton address.
    /// @dev Only callable by the owner.
    /// @param newSingleton The new singleton contract address.
    /// @param initData Encoded call to the setup function that will be called
    ///        on the proxy after switching the singleton.
    function upgradeSingleton(
        address newSingleton,
        bytes memory initData
    ) external onlyOwner {
        if (newSingleton == address(0) || newSingleton == address(this)) {
            revert InvalidNewSingletonAddress();
        }
        if (singleton == newSingleton) {
            revert SingletonAlreadyUpgraded();
        }

        emit SingletonUpgraded(singleton, newSingleton);

        singleton = newSingleton;

        if (initData.length == 0) {
            revert InvalidUpgradeInitData();
        }
        // The init function should return no data.
        // slither-disable-next-line unused-return
        Address.functionCall(address(this), initData);
    }

    /// @notice The function allows to upgrade the BitcoinSafeOwner singleton
    ///         address. Note that this action does not change the predicted
    ///         address of the deployed Safe but may change the address of the
    ///         BitcoinSafeOwner deployed for the Safe.
    /// @dev Only callable by the owner.
    /// @param newSafeOwnerSingleton The new BitcoinSafeOwner singleton contract
    ///        address.
    function upgradeSafeOwnerSingleton(
        address newSafeOwnerSingleton
    ) external onlyOwner {
        if (
            newSafeOwnerSingleton == address(0) ||
            newSafeOwnerSingleton == address(this)
        ) {
            revert InvalidNewSafeOwnerSingletonAddress();
        }
        if (safeOwnerSingleton == newSafeOwnerSingleton) {
            revert SafeOwnerSingletonAlreadyUpgraded();
        }

        emit SafeOwnerSingletonUpgraded(
            safeOwnerSingleton,
            newSafeOwnerSingleton
        );

        safeOwnerSingleton = newSafeOwnerSingleton;
    }

    /// @notice Transfers ownership of the contract to a new address.
    /// @dev Can only be called by the current owner.
    function transferOwnership(address newOwner) external onlyOwner {
        if (newOwner == address(0)) {
            revert InvalidNewOwnerAddress();
        }

        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }

    /// @notice Deploys the Safe proxy for the given salt and previously
    ///         deployed BitcoinSafeOwner proxy. The BitcoinSafeOwner proxy is
    ///         the sole owner of the deployed Safe. The deployed safe is a
    ///         vanilla safe with no additional modules.
    /// @param ownerProxy Instance of a BitcoinSafeOwner proxy contract that
    ///        is supposed to own the safe.
    /// @param salt The salt determining the deployed proxy address.
    function deploySafeProxy(
        address ownerProxy,
        bytes32 salt
    ) internal returns (SafeProxy proxy) {
        bytes memory deploymentData = abi.encodePacked(
            type(SafeProxy).creationCode,
            uint256(uint160(safeSingleton))
        );
        // solhint-disable-next-line no-inline-assembly
        assembly {
            proxy := create2(
                0x0,
                add(0x20, deploymentData),
                mload(deploymentData),
                salt
            )
        }
        require(address(proxy) != address(0), "Safe Proxy Create2 call failed");

        address[] memory owners = new address[](1);
        owners[0] = address(ownerProxy);

        // Enable Safe EIP-4337 module version 0.3.0.
        // https://github.com/safe-global/safe-modules/blob/466a9b8ef169003c5df856c6ecd295e6ecb9e99d/modules/4337/CHANGELOG.md?plain=1#L17
        address safeModuleSetup = 0x2dd68b007B46fBe91B9A7c3EDa5A7a1063cB5b47;
        address safe4337Module = 0x75cf11467937ce3F2f357CE24ffc3DBF8fD5c226;

        address[] memory modules = new address[](1);
        modules[0] = safe4337Module;

        bytes memory initializer = abi.encodeCall(
            Safe.setup,
            (
                owners, // owners
                1, // threshold
                safeModuleSetup, // to
                abi.encodeWithSignature("enableModules(address[])", modules), // data
                safe4337Module, // fallbackHandler
                address(0), // paymentToken
                0, // payment
                payable(0) // paymentReceiver
            )
        );

        // solhint-disable-next-line no-inline-assembly
        assembly {
            if eq(
                call(
                    gas(),
                    proxy,
                    0,
                    add(initializer, 0x20),
                    mload(initializer),
                    0,
                    0
                ),
                0
            ) {
                revert(0, 0)
            }
        }
    }

    /// @notice Deploys the BitcoinSafeOwner proxy for the given salt and
    ///         Bitcoin owner Ethereum address.
    /// @dev The code was borrowed from SafeProxyFactory.deployProxy at version
    ///      1.4.1-build.0 with small modifications.
    /// @param truncatedBitcoinAddress The main part of a decoded Bitcoin address
    ///        used for BitcoinSafeOwner initialization.
    /// @param salt The salt determining the deployed proxy address.
    function deployBitcoinSafeOwnerProxy(
        bytes20 truncatedBitcoinAddress,
        bytes32 salt
    ) internal returns (Proxy proxy) {
        bytes memory deploymentData = abi.encodePacked(
            type(Proxy).creationCode,
            uint256(uint160(safeOwnerSingleton))
        );

        // solhint-disable-next-line no-inline-assembly
        assembly {
            proxy := create2(
                0x0,
                add(0x20, deploymentData),
                mload(deploymentData),
                salt
            )
        }
        require(
            address(proxy) != address(0),
            "BitcoinSafeOwner Proxy Create2 call failed"
        );

        bytes memory initializer = abi.encodeCall(
            BitcoinSafeOwner.setup,
            (truncatedBitcoinAddress, emergencyGovernance)
        );
        // solhint-disable-next-line no-inline-assembly
        assembly {
            if eq(
                call(
                    gas(),
                    proxy,
                    0,
                    add(initializer, 0x20),
                    mload(initializer),
                    0,
                    0
                ),
                0
            ) {
                revert(0, 0)
            }
        }
    }

    /// @notice Predicts the address of the Safe proxy using the provided salt.
    /// @dev Utilizes the keccak256 hash of the contract creation bytecode, combined
    ///      with the salt, to compute the address using the CREATE2 rules.
    /// @param salt The unique salt used for the Safe proxy deployment, derived
    ///        from the `truncatedBitcoinAddress`.
    /// @return The predicted address of the Safe proxy based on the provided salt.
    function predictSafeAddress(bytes32 salt) internal view returns (address) {
        bytes memory deploymentData = abi.encodePacked(
            type(SafeProxy).creationCode,
            uint256(uint160(safeSingleton))
        );

        return computeAddress(salt, keccak256(deploymentData));
    }

    /// @notice Predicts the address of the BitcoinSafeOwner proxy using the
    ///         provided salt.
    /// @dev Uses the keccak256 hash of the BitcoinSafeOwner proxy creation bytecode
    ///      and the salt to calculate the CREATE2 deployment address.
    /// @param salt The unique salt used for the BitcoinSafeOwner proxy deployment,
    ///        derived from the `truncatedBitcoinAddress`.
    /// @return The predicted address of the BitcoinSafeOwner proxy based on the
    ///         provided salt.
    function predictBitcoinSafeOwnerAddress(
        bytes32 salt
    ) internal view returns (address) {
        bytes memory deploymentData = abi.encodePacked(
            type(Proxy).creationCode,
            uint256(uint160(safeOwnerSingleton))
        );

        return computeAddress(salt, keccak256(deploymentData));
    }

    /// @notice Computes the expected address for a contract deployed using `create2`.
    /// @dev This function calculates the address where a contract will be deployed
    ///      through the `create2` opcode, based on a provided `salt` and the hash
    ///      of the contract's bytecode (`bytecodeHash`). Changes in either `salt`
    ///      or `bytecodeHash` will lead to a different resultant address.
    /// @param salt A bytes32 value used as a salt in the `create2`.
    /// @param bytecodeHash The keccak256 hash of the contract's bytecode.
    /// @return addr The computed address where a contract would be stored if
    ///         deployed using `create2` with the specified `salt` and `bytecodeHash`.
    function computeAddress(
        bytes32 salt,
        bytes32 bytecodeHash
    ) internal view returns (address addr) {
        address deployer = address(this);

        // Implementation below is borrowed from the OpenZeppelin's Create2 contract.
        // Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d398d68944d6551cb1bad6bfe3bdbd35c2fe59f0/contracts/utils/Create2.sol

        // solhint-disable-next-line no-inline-assembly
        assembly {
            let ptr := mload(0x40) // Get free memory pointer

            // |                   | ↓ ptr ...  ↓ ptr + 0x0B (start) ...  ↓ ptr + 0x20 ...  ↓ ptr + 0x40 ...   |
            // |-------------------|---------------------------------------------------------------------------|
            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |
            // | salt              |                                      BBBBBBBBBBBBB...BB                   |
            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |
            // | 0xFF              |            FF                                                             |
            // |-------------------|---------------------------------------------------------------------------|
            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |
            // | keccak(start, 85) |            ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑ |

            mstore(add(ptr, 0x40), bytecodeHash)
            mstore(add(ptr, 0x20), salt)
            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes
            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff
            mstore8(start, 0xff)
            addr := and(
                keccak256(start, 85),
                0xffffffffffffffffffffffffffffffffffffffff
            )
        }
    }

    /// @notice Returns true if `account` is a contract.
    /// @dev This function will return false if invoked during the constructor of a contract,
    ///      as the code is not actually created until after the constructor finishes.
    /// @param account The address being queried
    /// @return True if `account` is a contract
    function isContract(address account) internal view returns (bool) {
        // Implementation below is borrowed from the Safe Global's SafeProfyFactory contract.
        // Source: https://github.com/safe-global/safe-smart-account/blob/192c7dc67290940fcbc75165522bb86a37187069/contracts/proxies/SafeProxyFactory.sol#L104

        uint256 size;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            size := extcodesize(account)
        }
        return size > 0;
    }
}
