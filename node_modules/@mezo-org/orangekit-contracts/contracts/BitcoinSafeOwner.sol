// SPDX-License-Identifier: GPL-3.0-only
pragma solidity 0.8.25;

import {ERC1271} from "./ERC1271.sol";
import {LegacyERC1271} from "./LegacyERC1271.sol";
import {EmergencyGovernance} from "./EmergencyGovernance.sol";

import {Address} from "@openzeppelin/contracts/utils/Address.sol";

/// @title BitcoinSafeOwner
/// @notice A contract to validate Bitcoin transaction signatures against an
///         Ethereum address derived from a Bitcoin public key.
/// @dev This contract implements ERC1271 and LegacyERC1271 to validate signatures
///      for Bitcoin messages, accommodating both current and legacy versions of
///      Safe contracts.
contract BitcoinSafeOwner is ERC1271, LegacyERC1271 {
    // Singleton always has to be the first declared variable to ensure the same
    // location as in the Proxy contract. It should also always be ensured the
    // address is stored alone (uses a full word). We add a one word gap to be
    // absolutely sure about it, no matter what fields will come next.
    // slither-disable-start constable-states
    // slither-disable-start unused-state
    address internal singleton;
    bytes32 internal __gap;
    // slither-disable-end constable-states
    // slither-disable-end unused-state

    /// @notice Version of the contract.
    /// @dev Must be increased for each new contract version to ensure off-chain
    ///      upgrade signatures can be used only one time.
    string public version;

    /// @notice Represents the main part of a decoded Bitcoin address, excluding
    ///         the network byte and checksum.
    /// @dev It captures the RIPEMD-160 hash of the SHA-256 hash of the public
    ///      key or redeem script hash, which is derived from a Bitcoin address
    ///      after removing its network byte and checksum.
    ///      This value is used for Bitcoin message signatures validation from
    ///      the Bitcoin account associated with this contract.
    bytes20 public truncatedBitcoinAddress;

    /// @notice Indicates if the setup function was already called for the contract.
    // slither-disable-next-line immutable-states
    bool public initialized;

    /// @notice Reference to the emergency governance contract holding the
    ///         emergency upgrader address that can execute upgrades of the
    ///         singleton address if the emergency upgrades were not disabled.
    EmergencyGovernance public emergencyGovernance;

    /// @notice Magic value for an invalid signature, indicating a failed validation.
    bytes4 internal constant INVALID_SIGNATURE_VALUE = 0xffffffff;

    /// @notice Typehash of a message signed off-chain to upgrade the singleton.
    bytes32 public constant UPGRADE_SINGLETON_TYPEHASH =
        keccak256("UpgradeSingleton(address newSingleton,bytes initData)");

    event SingletonUpgraded(address oldSingleton, address newSingleton);

    /// Reverts when the contract was already initialized and another
    /// initialization attempt is made.
    error ContractAlreadyInitialized();

    /// Reverts when truncated Bitcoin address is incorrect.
    error InvalidTruncatedBitcoinAddress();

    /// Reverts when emergency governance contract address is zero.
    error EmergencyGovernanceAddressZero();

    /// Reverts when provided signature is not 65-bytes long.
    error InvalidSignatureLength(uint256 actualLength);

    /// Reverts when the singleton was already upgraded to the given new version.
    error SingletonAlreadyUpgraded();

    /// Reverts when the new singleton address is incorrect.
    error InvalidNewSingletonAddress();

    /// Reverts when the upgrade order signature was incorrect.
    error InvalidUpgradeSignature();

    /// Reverts if the new version init data provided in the upgrade order
    /// are empty.
    error InvalidUpgradeInitData();

    /// Reverts when the address calling the function is not the authorized
    /// emergency governance upgrader.
    error InvalidEmergencyGovernanceCaller();

    constructor() {
        // Prevent singleton contract initialization.
        initialized = true;
    }

    /// @notice Initializes the BitcoinSafeOwner contract with the Ethereum
    ///         address derived from a Bitcoin public key and the address
    ///         of the contract holding the emergency governance settings.
    function setup(
        bytes20 _truncatedBitcoinAddress,
        address _emergencyGovernance
    ) external {
        if (initialized) {
            revert ContractAlreadyInitialized();
        }

        if (_truncatedBitcoinAddress == bytes20(0)) {
            revert InvalidTruncatedBitcoinAddress();
        }

        if (_emergencyGovernance == address(0)) {
            revert EmergencyGovernanceAddressZero();
        }

        initialized = true;
        emergencyGovernance = EmergencyGovernance(_emergencyGovernance);
        truncatedBitcoinAddress = _truncatedBitcoinAddress;

        // IMPORTANT: The contract version is a part of the DOMAIN_SEPARATOR.
        // The new singleton implementation MUST increase the version number
        // to protect against replaying signatures.
        version = "v1.0.0";
    }

    /// @notice Returns the hash of EIP712 domain separator struct. Used to
    ///         verify off-chain signatures to this contract, such as the
    ///         signature for upgrading the singleton.
    function DOMAIN_SEPARATOR() public view returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    keccak256(
                        "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"
                    ),
                    keccak256(bytes("BitcoinSafeOwner")),
                    keccak256(bytes(version)),
                    block.chainid,
                    address(this)
                )
            );
    }

    /// @notice Upgrades the singleton address based on the signature of the
    ///         upgrade order prepared off-chain.
    /// @dev IMPORTANT: The contract version is a part of the DOMAIN_SEPARATOR.
    ///      The new singleton implementation MUST increase the version number
    ///      to protect against replaying signatures.
    /// @param newSingleton The new singleton contract address.
    /// @param initData Encoded call to the setup function that will be called
    ///        on the proxy after switching the singleton.
    /// @param signature The signature from the Bitcoin signer attesting the
    ///        upgrade order.
    function upgradeSingleton(
        address newSingleton,
        bytes memory initData,
        bytes memory signature
    ) external {
        if (newSingleton == address(0) || newSingleton == address(this)) {
            revert InvalidNewSingletonAddress();
        }
        if (singleton == newSingleton) {
            revert SingletonAlreadyUpgraded();
        }

        bytes32 digest = keccak256(
            abi.encodePacked(
                "\x19\x01",
                DOMAIN_SEPARATOR(),
                keccak256(
                    abi.encode(
                        UPGRADE_SINGLETON_TYPEHASH,
                        newSingleton,
                        initData
                    )
                )
            )
        );

        if (!validateSignature(digest, signature)) {
            revert InvalidUpgradeSignature();
        }

        emit SingletonUpgraded(singleton, newSingleton);

        singleton = newSingleton;

        if (initData.length == 0) {
            revert InvalidUpgradeInitData();
        }
        // The init function should return no data.
        // slither-disable-next-line unused-return
        Address.functionCall(address(this), initData);
    }

    /// @notice Upgrades the singleton address in an emergency mode.
    /// @dev Only callable by the governance upgrader set in the
    ///      EmergencyGovernance contract.
    /// @param newSingleton The new singleton contract address.
    /// @param initData Encoded call to the setup function that will be called
    ///        on the proxy after switching the singleton.
    function emergencyUpgradeSingleton(
        address newSingleton,
        bytes memory initData
    ) external {
        if (newSingleton == address(0) || newSingleton == address(this)) {
            revert InvalidNewSingletonAddress();
        }
        if (singleton == newSingleton) {
            revert SingletonAlreadyUpgraded();
        }

        if (msg.sender != emergencyGovernance.emergencyUpgrader()) {
            revert InvalidEmergencyGovernanceCaller();
        }

        emit SingletonUpgraded(singleton, newSingleton);

        singleton = newSingleton;

        if (initData.length == 0) {
            revert InvalidUpgradeInitData();
        }
        // The init function should return no data.
        // slither-disable-next-line unused-return
        Address.functionCall(address(this), initData);
    }

    /// @notice Validates a signature against a hash digest, adhering to the latest
    ///         ERC-1271 standard.
    /// @param digest The hash of the data that was signed.
    /// @param signature The signature bytes to be validated.
    /// @return magicValue A magic value indicating the result of the validation.
    /// @dev This method is intended to comply with the most recent version of
    ///      Safe contracts.
    function isValidSignature(
        bytes32 digest,
        bytes memory signature
    ) external view returns (bytes4 magicValue) {
        return
            validateSignature(digest, signature)
                ? ERC1271_MAGIC_VALUE
                : INVALID_SIGNATURE_VALUE;
    }

    /// @notice Validates a signature against data bytes, following the legacy
    ///         Safe contract expectations.
    /// @param data Arbitrary length data that was signed.
    /// @param signature The signature bytes to be validated.
    /// @return magicValue A magic value indicating the result of the validation.
    /// @dev This method is compatible with Safe contracts up to version 1.4.1.
    function isValidSignature(
        bytes memory data,
        bytes memory signature
    ) public view override returns (bytes4 magicValue) {
        bytes32 digest = keccak256(data);

        return
            validateSignature(digest, signature)
                ? LEGACY_SAFE_ERC1271_MAGIC_VALUE
                : INVALID_SIGNATURE_VALUE;
    }

    /// @notice Internal function to validate a signature against a digest.
    /// @dev By adjusting the recovery byte (`v`) it supports various types of
    ///      Bitcoin truncated addresses that this contract could be initialized
    ///      with, including uncompressed P2PKH, compressed P2PKH, compressed
    ///      P2WPKH, and compressed P2SH-P2WPKH.
    ///      The function returns `true` if the signature is successfully verified
    ///      against the `digest` and the `truncatedBitcoinAddress` stored in the
    ///      contract.
    /// @param digest The hash of the data that was signed.
    /// @param signature The signature bytes to be validated, which must be 129
    ///        bytes long and include the `v`, `r`, `s` values of the
    ///        ECDSA signature, and the `x`, `y` coordinates of the public key
    ///        used for signing. The `v` value should be adjusted to indicate
    ///        which signature validation function should be executed for the given
    ///        truncated Bitcoin address type.
    /// @return A boolean indicating whether the signature is valid.
    function validateSignature(
        bytes32 digest,
        bytes memory signature
    ) internal view returns (bool) {
        if (truncatedBitcoinAddress == bytes20(0))
            revert InvalidTruncatedBitcoinAddress();

        if (signature.length != 129)
            revert InvalidSignatureLength(signature.length);

        uint8 v;
        bytes32 r;
        bytes32 s;
        bytes32 x;
        bytes32 y;
        // solhint-disable-next-line no-inline-assembly
        assembly {
            // first 32 bytes, after the length prefix.
            r := mload(add(signature, 32))
            // second 32 bytes.
            s := mload(add(signature, 64))
            // 65th byte (first byte of the next 32 bytes).
            v := byte(0, mload(add(signature, 96)))
            // next 32 bytes starting from 65
            x := mload(add(signature, 97))
            // last 32 bytes
            y := mload(add(signature, 129))
        }

        // Update v to normalize its value to the expected range.
        bool shouldEncode = false;
        (shouldEncode, v) = shouldEncodeDigest(v);

        bytes memory signedMessagePreimage;
        if (shouldEncode) {
            bytes memory encodedDigest = encodeDigest(digest);
            signedMessagePreimage = abi.encodePacked(
                "\x18Bitcoin Signed Message:\n",
                // Length should be always 64-byte but read it dynamically just in case.
                // Note that wallets encode digest length as Bitcoin varint,
                // so if the encoding logic ever changes and starts producing
                // results longer than 253 bytes, this will need to be updated.
                uint8(encodedDigest.length),
                encodedDigest
            );
        } else {
            signedMessagePreimage = abi.encodePacked(
                "\x18Bitcoin Signed Message:\n",
                uint8(32),
                digest
            );
        }

        bytes32 signedMessage = sha256(
            abi.encodePacked(sha256(signedMessagePreimage))
        );

        // The v value must be 27 or 28 for ECRECOVER to accept the signatures.
        // In the case of uncompressed P2PKH addresses this is achieved as long
        // as the signature's r value is less than the curve order n.
        // When the v value is used to encode a different signature type,
        // we need to subtract the difference to get 27 or 28.
        // Signatures with r greater than n, corresponding to the v values
        // 29, 30, 33, 34, 37, 38, 41 or 42 cannot be accepted by ECRECOVER.
        // Signature's V value is used to determine signature verification path
        // according to BIP-137.
        if (v == 27 || v == 28) {
            // v is either 27 or 28, so pass it straight to ECRECOVER
            return validateUncompressedP2PKH(signedMessage, v, r, s, x, y);
        } else if (v == 31 || v == 32) {
            // v is either 31 or 32, so subtract 4 to get 27 or 28
            return validateCompressedP2PKH(signedMessage, v - 4, r, s, x, y);
        } else if (v == 35 || v == 36) {
            // v is either 35 or 36, so subtract 8 to get 27 or 28
            return validateP2SH_P2WPKH(signedMessage, v - 8, r, s, x, y);
        } else if (v == 39 || v == 40) {
            // v is either 39 or 40, so subtract 12 to get 27 or 28
            return validateP2WPKH(signedMessage, v - 12, r, s, x, y);
        } else {
            return false;
        }
    }

    /// @notice Validates a signature for truncated Bitcoin address derived from
    ///         a P2PKH address of an uncompressed public key.
    /// @param signedMessage The SHA-256 hash of the message that was signed,
    ///        prefixed according to the Bitcoin signed message standard.
    /// @param v The recovery byte.
    /// @param r The first component of the ECDSA signature.
    /// @param s The second component of the ECDSA signature.
    /// @param x The x-coordinate of the public key.
    /// @param y The y-coordinate of the public key.
    /// @return A boolean indicating whether the signature is valid.
    function validateUncompressedP2PKH(
        bytes32 signedMessage,
        uint8 v,
        bytes32 r,
        bytes32 s,
        bytes32 x,
        bytes32 y
    ) internal view returns (bool) {
        uint8 prefix = uint8(4);
        bytes20 publicKeyHash = hash160(abi.encodePacked(prefix, x, y));

        return
            ecrecover(signedMessage, v, r, s) ==
            publicKeyToEthereumAddress(x, y) &&
            truncatedBitcoinAddress == publicKeyHash;
    }

    /// @notice Validates a signature for truncated Bitcoin address derived from
    ///         a P2PKH address of a compressed public key.
    /// @param signedMessage The SHA-256 hash of the message that was signed,
    ///        prefixed according to the Bitcoin signed message standard.
    /// @param v The recovery byte.
    /// @param r The first component of the ECDSA signature.
    /// @param s The second component of the ECDSA signature.
    /// @param x The x-coordinate of the public key.
    /// @param y The y-coordinate of the public key.
    /// @return A boolean indicating whether the signature is valid.
    function validateCompressedP2PKH(
        bytes32 signedMessage,
        uint8 v,
        bytes32 r,
        bytes32 s,
        bytes32 x,
        bytes32 y
    ) internal view returns (bool) {
        uint8 prefix = uint8(uint256(y) & 1) + uint8(2);
        bytes20 publicKeyHash = hash160(abi.encodePacked(prefix, x));

        return
            ecrecover(signedMessage, v, r, s) ==
            publicKeyToEthereumAddress(x, y) &&
            truncatedBitcoinAddress == publicKeyHash;
    }

    /// @notice Validates a signature for truncated Bitcoin address derived from
    ///         a P2SH-P2WPKH address of a compressed public key.
    /// @param signedMessage The SHA-256 hash of the message that was signed,
    ///        prefixed according to the Bitcoin signed message standard.
    /// @param v The recovery byte.
    /// @param r The first component of the ECDSA signature.
    /// @param s The second component of the ECDSA signature.
    /// @param x The x-coordinate of the public key.
    /// @param y The y-coordinate of the public key.
    /// @return A boolean indicating whether the signature is valid.
    function validateP2SH_P2WPKH(
        bytes32 signedMessage,
        uint8 v,
        bytes32 r,
        bytes32 s,
        bytes32 x,
        bytes32 y
    ) internal view returns (bool) {
        uint8 prefix = uint8(uint256(y) & 1) + uint8(2);
        bytes20 publicKeyHash = hash160(abi.encodePacked(prefix, x));

        bytes20 redeemScriptHash = hash160(
            abi.encodePacked(bytes2(hex"0014"), publicKeyHash)
        );

        return
            ecrecover(signedMessage, v, r, s) ==
            publicKeyToEthereumAddress(x, y) &&
            truncatedBitcoinAddress == redeemScriptHash;
    }

    /// @notice Validates a signature for truncated Bitcoin address derived from
    ///         a PW2PKH address of a compressed public key.
    /// @param signedMessage The SHA-256 hash of the message that was signed,
    ///        prefixed according to the Bitcoin signed message standard.
    /// @param v The recovery byte.
    /// @param r The first component of the ECDSA signature.
    /// @param s The second component of the ECDSA signature.
    /// @param x The x-coordinate of the public key.
    /// @param y The y-coordinate of the public key.
    /// @return A boolean indicating whether the signature is valid.
    function validateP2WPKH(
        bytes32 signedMessage,
        uint8 v,
        bytes32 r,
        bytes32 s,
        bytes32 x,
        bytes32 y
    ) internal view returns (bool) {
        uint8 prefix = uint8(uint256(y) & 1) + uint8(2);
        bytes20 publicKeyHash = hash160(abi.encodePacked(prefix, x));

        return
            ecrecover(signedMessage, v, r, s) ==
            publicKeyToEthereumAddress(x, y) &&
            truncatedBitcoinAddress == publicKeyHash;
    }

    /// @notice Converts a public key (x, y coordinates) to an Ethereum address
    /// @dev Computes the Ethereum address by performing a keccak256 hash on the
    ///      concatenated x and y coordinates of the public key, then taking the
    ///      last 20 bytes of the hash (as per Ethereum's address format).
    /// @param x The x-coordinate of the public key.
    /// @param y The y-coordinate of the public key.
    /// @return The Ethereum address derived from the public key.
    function publicKeyToEthereumAddress(
        bytes32 x,
        bytes32 y
    ) internal pure returns (address) {
        return address(uint160(uint256(keccak256(abi.encodePacked(x, y)))));
    }

    /// @notice Calculate hash160 for the given input bytes.
    /// @dev This function combines SHA-256 and RIPEMD-160 hashing to produce a
    ///      hash commonly used in Bitcoin addressing.
    /// @param input The bytes array to be hashed.
    /// @return The hash160 (RIPEMD-160 of a SHA-256 hash) of the input.
    function hash160(bytes memory input) internal pure returns (bytes20) {
        return ripemd160(abi.encodePacked(sha256(input)));
    }

    // Byte array mapping bytes into UTF-8 characters. The index represents
    // a byte, the value is the UTF-8 character encoding for the byte:
    // 0 -> 0x30
    // 1 -> 0x31
    // ...
    // 9 -> 0x39
    // a -> 0x61
    // b -> 0x62
    // ...
    // f -> 0x66
    bytes16 internal constant encoding = hex"30313233343536373839616263646566";

    /// @notice The function encodes 32-byte digest into 64-byte UTF-8 hex
    ///         string. Some Bitcoin wallets may not support signing raw data
    ///         and instead, treat the input of the signed message as UTF-8
    ///         strings. For example, if the raw bytes message to be signed is
    ///         `ffdd`, the wallet may interpret it a UTF-8 characters (f = 66,
    ///         d = 64): `66666464`.
    /// @param digest The digest to be encoded into UTF-8 string.
    /// @return The digest as a UTF-8 encoded string.
    function encodeDigest(bytes32 digest) internal pure returns (bytes memory) {
        uint256 localValue = uint256(digest);
        bytes memory buffer = new bytes(64);
        for (uint256 i = 63; i > 0; --i) {
            buffer[i] = encoding[localValue & 0xf];
            localValue >>= 4;
        }
        buffer[0] = encoding[localValue & 0xf];

        return buffer;
    }

    /// @notice Checks the highest bit of the recovery byte v to decide whether
    ///         the digest should be treated as a UTF-8-encoded string. If the
    ///         highest bit of v is set, the digest should be encoded with the
    ///         `encodeDigest` function. If the highest bit is not set, the
    ///         digest should be passed to the verification function as-is.
    ///         The second returned value is the recover byte v without the
    ///         highest bit set that can be passed to the verification function.
    /// @param v The recovery byte v set in the signature.
    /// @return Boolean indicating whether the digest should be encoded into
    ///         UTF-8 string and the recovery byte v without the highest bit
    ///         set.
    function shouldEncodeDigest(uint8 v) internal pure returns (bool, uint8) {
        return v >= 128 ? (true, v - 128) : (false, v);
    }
}
