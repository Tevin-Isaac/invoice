import { AbstractSigner, } from "ethers";
class OrangeKitEthersSigner extends AbstractSigner {
    static init(provider, ethAddress, bitcoinWallet, orangekitSmartAccount) {
        return new OrangeKitEthersSigner(provider, ethAddress, bitcoinWallet, orangekitSmartAccount);
    }
    #bitcoinWallet;
    #address;
    #orangekitSmartAccount;
    constructor(provider, ethAddress, bitcoinWallet, orangekitSmartAccount) {
        super(provider);
        this.#address = ethAddress;
        this.#bitcoinWallet = bitcoinWallet;
        this.#orangekitSmartAccount = orangekitSmartAccount;
    }
    async signMessage(_message) {
        return this.#bitcoinWallet.signMessage(_message.toString());
    }
    async sendBitcoin(address, amount) {
        return this.#bitcoinWallet.sendBitcoin(address, amount);
    }
    async getAddress() {
        return Promise.resolve(this.#address);
    }
    async getBalance() {
        return Promise.resolve(this.#bitcoinWallet.getBalance());
    }
    async getBitcoinAddress() {
        return Promise.resolve(this.#bitcoinWallet.getAddress());
    }
    connect(provider) {
        return new OrangeKitEthersSigner(provider, this.#address, this.#bitcoinWallet, this.#orangekitSmartAccount);
    }
    async waitForTransactionResponse(hash, maxRetries = 30, delayMs = 1000) {
        let retries = 0;
        while (retries < maxRetries) {
            const txResponse = 
            // eslint-disable-next-line no-await-in-loop
            await this.#orangekitSmartAccount.provider.getTransaction(hash);
            if (txResponse) {
                return txResponse;
            }
            // Wait for the given delay before we retry
            // eslint-disable-next-line no-await-in-loop
            await new Promise((resolve) => {
                setTimeout(resolve, delayMs);
            });
            retries += 1;
        }
        throw new Error(`Transaction not found after ${maxRetries} retries.`);
    }
    async sendTransaction(transactionRequest, maxRetries, delayMs) {
        const hash = await this.#orangekitSmartAccount.sendTransaction(transactionRequest.to ?? "", (transactionRequest.value ?? 0n).toString(), transactionRequest.data ?? "", await this.#bitcoinWallet.getAddress(), await this.#bitcoinWallet.getPublicKey(), (message) => this.#bitcoinWallet.signMessage(message));
        return this.waitForTransactionResponse(hash, maxRetries, delayMs);
    }
    // eslint-disable-next-line class-methods-use-this
    signTransaction() {
        throw new Error("Unsupported method");
    }
    // eslint-disable-next-line class-methods-use-this
    signTypedData() {
        throw new Error("Unsupported method");
    }
    // We must add this to be compatible with ethers v5 and tbtc-v2.ts lib.
    getNetwork() {
        return this.provider?.getNetwork();
    }
    // We must add this to be compatible with ethers v5 and tbtc-v2.ts lib.
    _isSigner = true;
    // We must add this to be compatible with ethers v5 and tbtc-v2.ts lib.
    // eslint-disable-next-line no-underscore-dangle
    _checkProvider() {
        if (!this.provider)
            throw new Error("Provider not available");
    }
    // We must add this to be compatible with ethers v5 and tbtc-v2.ts lib.
    async getChainId() {
        // eslint-disable-next-line no-underscore-dangle
        this._checkProvider();
        const network = await this.provider.getNetwork();
        return Number(network.chainId);
    }
}
// eslint-disable-next-line import/prefer-default-export
export { OrangeKitEthersSigner };
//# sourceMappingURL=ethers-signer.js.map