import { createWalletClient, http } from "viem";
import { toAccount } from "viem/accounts";
import { mainnet, matsnetTestnetChain, sepolia } from "./chains";
const supportedChains = [mainnet, sepolia, matsnetTestnetChain];
export function createOrangeKitClient({ address, bitcoinWalletProvider, rpcUrl, chainId, orangeKitSmartAccount, }) {
    const account = toAccount({
        // @ts-expect-error we want to try return btc address
        address,
        async signMessage({ message }) {
            const messageToSign = typeof message === "string" ? message : message.raw.toString();
            const signedMessage = await bitcoinWalletProvider.signMessage(messageToSign);
            return signedMessage;
        },
        // @ts-expect-error TODO fix this error.
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async signTransaction() {
            // TODO: sign transaction here.
            const tx = {};
            return Promise.resolve(tx);
        },
        signTypedData() {
            throw new Error("Unsupported method");
        },
    });
    const chain = supportedChains.find((_chain) => _chain.id === chainId);
    if (!chain)
        throw new Error("Unsupported chain");
    return createWalletClient({
        chain,
        account,
        transport: http(rpcUrl),
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
    }).extend((client) => ({
        async sendBitcoin(to, satoshis) {
            const txHash = await bitcoinWalletProvider.sendBitcoin(to, satoshis);
            return txHash;
        },
        async sendTransaction({ to, value, data }) {
            return (await orangeKitSmartAccount.sendTransaction(to ?? "", (value ?? 0n).toString(), data ?? "", await bitcoinWalletProvider.getAddress(), await bitcoinWalletProvider.getPublicKey(), (message) => bitcoinWalletProvider.signMessage(message))); // cast to Hex to match return type of sendTransaction
        },
    }));
}
//# sourceMappingURL=client.js.map