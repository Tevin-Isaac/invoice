import Wallet, {
  AddressPurpose,
  RpcErrorCode,
  setDefaultProvider,
  MessageSigningProtocols,
} from "sats-connect"
import {
  Balance,
  InjectedProvider,
  ProviderSignature,
  ProviderTxId,
} from "../bitcoin-wallet-provider"
import {
  EIP1193_ERROR_CODES,
  EIP1193Error,
  serializeError,
} from "./EIP1193Error"

export default class XverseInjectedProvider implements InjectedProvider {
  #addresses: string[] = []

  #publicKey: string = ""

  #isBalancePermissionGiven: boolean = false

  /**
   * Workaround to avoid the external sats-connect modal with the possibility
   * to choose wallet. We should use this function when connecting an account
   * or when there is possibility to call a method without account connected.
   */
  // eslint-disable-next-line class-methods-use-this
  private setDefaultProviderToXverse(): void {
    setDefaultProvider("XverseProviders.BitcoinProvider")
  }

  // Disabling ESLint rule because this method implements an interface
  // method which cannot be declared static.
  // eslint-disable-next-line class-methods-use-this
  async requestAccounts(): Promise<string[]> {
    this.setDefaultProviderToXverse()
    if (this.#addresses.length > 0) {
      return this.#addresses
    }

    const requestPermissionResponse = await Wallet.request(
      "wallet_requestPermissions",
      undefined,
    )

    if (requestPermissionResponse.status === "error") {
      // User declined
      this.#isBalancePermissionGiven = false
      throw new Error("User declined connection.")
    }

    this.#isBalancePermissionGiven = true

    const response = await Wallet.request("getAddresses", {
      purposes: [AddressPurpose.Payment],
      message: "Address for receiving payments",
    })

    if (response.status === "error") {
      if (response.error.code === RpcErrorCode.USER_REJECTION) {
        throw serializeError(
          new EIP1193Error(EIP1193_ERROR_CODES.userRejectedRequest),
        )
      }

      throw Error(response.error.message)
    }

    this.#addresses = response.result.addresses.map(
      ({ address }: { address: string }) => address,
    )
    ;[this.#publicKey] = response.result.addresses.map(
      ({ publicKey }: { publicKey: string }) => publicKey,
    )

    return this.#addresses
  }

  async getAccounts(): Promise<string[]> {
    return this.#addresses
  }

  // eslint-disable-next-line class-methods-use-this
  async getBalance(): Promise<Balance> {
    if (!this.#isBalancePermissionGiven) {
      throw new Error(
        "Failed to get balance! Permission to retrieve balance was not given.",
      )
    }

    const getBalanceResponse = await Wallet.request("getBalance", undefined)

    if (getBalanceResponse.status === "error") {
      // Something went wrong.
      throw new Error("Failed to get balance.", {
        cause: getBalanceResponse.error,
      })
    }

    const { confirmed, unconfirmed, total } = getBalanceResponse.result

    return {
      confirmed: Number(confirmed),
      unconfirmed: Number(unconfirmed),
      total: Number(total),
    }
  }

  async signMessage(message: string): Promise<ProviderSignature> {
    const address = (await this.getAccounts())[0]

    const response = await Wallet.request("signMessage", {
      address,
      message,
      protocol: MessageSigningProtocols.ECDSA,
    })

    if (response.status === "error") {
      if (response.error.code === RpcErrorCode.USER_REJECTION) {
        throw serializeError(
          new EIP1193Error(EIP1193_ERROR_CODES.userRejectedRequest),
        )
      }

      throw Error(response.error.message)
    }

    return response.result.signature
  }

  // eslint-disable-next-line class-methods-use-this
  async sendBitcoin(to: string, satoshis: number): Promise<ProviderTxId> {
    const response = await Wallet.request("sendTransfer", {
      recipients: [
        {
          address: to,
          amount: satoshis,
        },
      ],
    })

    if (response.status === "error") {
      if (response.error.code === RpcErrorCode.USER_REJECTION) {
        throw serializeError(
          new EIP1193Error(EIP1193_ERROR_CODES.userRejectedRequest),
        )
      }

      throw Error(response.error.message)
    }

    return response.result.txid
  }

  async getPublicKey(): Promise<string> {
    this.setDefaultProviderToXverse()
    if (this.#publicKey.length > 0) {
      return this.#publicKey
    }
    const response = await Wallet.request("getAddresses", {
      purposes: [AddressPurpose.Payment],
      message: "Address for receiving payments",
    })

    if (response.status === "error") {
      if (response.error.code === RpcErrorCode.USER_REJECTION) {
        throw serializeError(
          new EIP1193Error(EIP1193_ERROR_CODES.userRejectedRequest),
        )
      }

      throw Error(response.error.message)
    }

    ;[this.#publicKey] = response.result.addresses.map(
      ({ publicKey }: { publicKey: string }) => publicKey,
    )

    return this.#publicKey
  }

  async disconnect(): Promise<void> {
    await Wallet.request("wallet_renouncePermissions", undefined)

    this.#publicKey = ""
    this.#addresses = []
    this.#isBalancePermissionGiven = false
  }
}
