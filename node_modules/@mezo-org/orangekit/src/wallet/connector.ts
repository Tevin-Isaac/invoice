import {
  BitcoinAddressHelper,
  GelatoTransactionSender,
  MezoTransactionSender,
  OrangeKitSmartAccount,
} from "@mezo-org/orangekit-smart-account"
import { Provider } from "ethers"
import { createConnector, CreateConnectorFn, normalizeChainId } from "wagmi"
import { getAddress } from "viem"
import { OrangeKitBitcoinWalletProvider } from "./bitcoin-wallet-provider"
import { OrangeKitEthersSigner } from "./ethers-signer"
import { createOrangeKitClient } from "./client"
import {
  BitcoinWalletConnectionError,
  WalletNetworkDoesNotMatchProviderChainError,
} from "./errors"
import { OrangeKitWalletId, OrangeKitWalletName } from "./types"
import { getWalletInjectedProvider } from "./utils"
import { matsnetTestnetChain } from "./chains"

type ConnectorProperties = {
  toEthersSigner(provider: Provider): OrangeKitEthersSigner
  getBitcoinAddress(): Promise<string>
  getBitcoinProvider(): OrangeKitBitcoinWalletProvider
}

export type ConnectorConfig = {
  rpcUrl: string
  chainId: number
  relayApiKey: string
}

export type CreateOrangeKitConnectorFn = CreateConnectorFn<
  OrangeKitSmartAccount,
  ConnectorProperties
>

export type UnisatWagmiConnector = ReturnType<CreateOrangeKitConnectorFn>

function selectTransactionSender(chainId: number, gelatoApiKey: string) {
  switch (chainId) {
    case 31611: // Mezo matsnet
      return new MezoTransactionSender()
    default:
      return new GelatoTransactionSender(gelatoApiKey)
  }
}

export function createOrangeKitConnector(
  id: OrangeKitWalletId,
  name: OrangeKitWalletName,
  icon: string,
  rpcUrl: ConnectorConfig["rpcUrl"],
  initialChainId: ConnectorConfig["chainId"],
  bitcoinWalletProvider: OrangeKitBitcoinWalletProvider,
  relayApiKey: string,
): CreateOrangeKitConnectorFn {
  let orangeKitSmartAccount: OrangeKitSmartAccount
  let ethersSigner: OrangeKitEthersSigner

  if (initialChainId !== matsnetTestnetChain.id && relayApiKey === "")
    throw new Error("Relay API key is required")

  return createConnector<OrangeKitSmartAccount, ConnectorProperties>(
    ({ chains, emitter }) => ({
      id,
      uid: id,
      name,
      type: "orangekit",
      icon,
      async setup() {
        // We can reinitialize the smart account on `switchChain`.
        orangeKitSmartAccount = await OrangeKitSmartAccount.init(
          initialChainId,
          rpcUrl,
          selectTransactionSender(initialChainId, relayApiKey),
        )
      },
      async connect({ chainId }: { chainId: number }) {
        try {
          if (!bitcoinWalletProvider.isInstalled()) {
            // Try to get the injected provider one more time, just in-case it
            // was missed during the lib initialization (e.g. because a wallet
            // was not yet available at that time).
            const provider = getWalletInjectedProvider(id)
            bitcoinWalletProvider.setProvider(provider!)

            if (!bitcoinWalletProvider.isInstalled()) {
              throw new Error(`${name} wallet is not installed`)
            }
          }
          // Ask for permission.
          const isChainSupported = chains.some((chain) => chain.id === chainId)
          const providerChainId = await this.getChainId()

          if (!isChainSupported || providerChainId !== chainId)
            throw new Error("Unsupported network ")

          await bitcoinWalletProvider.connect()

          const btcAddress = await bitcoinWalletProvider.getAddress()

          const doesBitcoinAddressNetworkMatchWithProviderChain =
            providerChainId === 1 || providerChainId === matsnetTestnetChain.id
              ? BitcoinAddressHelper.isMainnetAddress
              : BitcoinAddressHelper.isTestnetAddress

          if (
            btcAddress &&
            !doesBitcoinAddressNetworkMatchWithProviderChain(btcAddress)
          ) {
            throw new WalletNetworkDoesNotMatchProviderChainError()
          }

          const accounts = await this.getAccounts()
          const [account] = accounts
          ethersSigner = OrangeKitEthersSigner.init(
            null,
            account,
            bitcoinWalletProvider,
            orangeKitSmartAccount,
          )

          return {
            chainId: providerChainId,
            accounts,
          }
        } catch (err) {
          if (err instanceof Error) {
            const error = new BitcoinWalletConnectionError(name, err)

            emitter.emit("error", { error })
            throw error
          } else {
            throw new Error(
              "Something went wrong when trying to connect the wallet.",
            )
          }
        }
      },
      disconnect() {
        return bitcoinWalletProvider.disconnect()
      },
      async getAccounts() {
        const bitcoinAddress = await this.getBitcoinAddress()
        const publicKey = await bitcoinWalletProvider.getPublicKey()

        const ethAddress = await orangeKitSmartAccount.predictAddress(
          bitcoinAddress,
          publicKey,
        )

        return [getAddress(ethAddress)]
      },
      async getProvider(parameters?: { chainId?: number }) {
        let selectedChainId = initialChainId

        if (parameters && "chainId" in parameters && parameters.chainId) {
          selectedChainId = parameters.chainId
        }
        // TODO: What should we return here? We have custom client for this
        // connector so the custom client will be always used as provider in
        // wagmi.
        if (
          !orangeKitSmartAccount ||
          selectedChainId !== orangeKitSmartAccount.chainId
        )
          orangeKitSmartAccount = await OrangeKitSmartAccount.init(
            selectedChainId,
            rpcUrl,
            selectTransactionSender(selectedChainId, relayApiKey),
          )

        return Promise.resolve(orangeKitSmartAccount)
      },
      async getChainId() {
        const provider = await this.getProvider()

        return normalizeChainId(provider.chainId)
      },
      async isAuthorized() {
        if (!bitcoinWalletProvider.isInstalled()) return false
        try {
          const account = await bitcoinWalletProvider?.getAddress()

          return !!account
        } catch (error) {
          return false
        }
      },
      async getClient() {
        const chainId = await this.getChainId()
        const [account] = await this.getAccounts()

        return createOrangeKitClient({
          chainId,
          bitcoinWalletProvider,
          rpcUrl,
          address: account,
          orangeKitSmartAccount,
        })
      },
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onAccountsChanged(accounts) {},
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onChainChanged(chainId) {},
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onConnect(connectInfo) {},
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onDisconnect(error) {},
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onMessage(message) {},
      toEthersSigner(provider: Provider) {
        return ethersSigner.connect(provider)
      },
      getBitcoinAddress() {
        return bitcoinWalletProvider.getAddress()
      },
      getBitcoinProvider() {
        return bitcoinWalletProvider
      },
    }),
  )
}
