import {
  BitcoinAddressHelper,
  GelatoTransactionSender,
  mezoTestnet,
  GelatoTransactionSenderConfig,
  MezoTransactionSender,
  OrangeKitSmartAccount,
  mezoMainnet,
} from "@mezo-org/orangekit-smart-account"
import { createConnector, CreateConnectorFn, normalizeChainId } from "wagmi"
import { getAddress } from "viem"
import { OrangeKitBitcoinWalletProvider } from "./bitcoin-wallet-provider"
import { createOrangeKitClient } from "./client"
import {
  BitcoinWalletConnectionError,
  WalletNetworkDoesNotMatchProviderChainError,
} from "./errors"
import { OrangeKitWalletId, OrangeKitWalletName } from "./types"
import { getWalletInjectedProvider } from "./utils"

type ConnectorProperties = {
  getBitcoinAddress(): Promise<string>
  getBitcoinProvider(): OrangeKitBitcoinWalletProvider
}

export type ConnectorConfig = {
  rpcUrl: string
  chainId: number
  relayApiKey?: string
  relayConfig?: GelatoTransactionSenderConfig
}

export type CreateOrangeKitConnectorFn = CreateConnectorFn<
  OrangeKitSmartAccount,
  ConnectorProperties
>

export type OrangeKitConnector = ReturnType<CreateOrangeKitConnectorFn>

export type UnisatWagmiConnector = ReturnType<CreateOrangeKitConnectorFn>

function selectTransactionSender(
  chainId: number,
  gelatoApiKey?: string,
  relayConfig?: GelatoTransactionSenderConfig,
) {
  switch (chainId) {
    case 31611: // Mezo Testnet
    case 31612: // Mezo Mainnet
      return new MezoTransactionSender(chainId)
    default:
      if (!gelatoApiKey)
        throw new Error(
          "Gelato API key is required for chain other than Matsnet",
        )
      return new GelatoTransactionSender(gelatoApiKey, relayConfig)
  }
}

export function createOrangeKitConnector(
  id: OrangeKitWalletId,
  name: OrangeKitWalletName,
  icon: string,
  rpcUrl: ConnectorConfig["rpcUrl"],
  initialChainId: ConnectorConfig["chainId"],
  bitcoinWalletProvider: OrangeKitBitcoinWalletProvider,
  relayApiKey?: string,
  relayConfig?: GelatoTransactionSenderConfig,
): CreateOrangeKitConnectorFn {
  let orangeKitSmartAccount: OrangeKitSmartAccount

  if (
    initialChainId !== mezoTestnet.id &&
    initialChainId !== mezoMainnet.id &&
    !relayApiKey
  )
    throw new Error("Relay API key is required for chain other than Mezo")

  return createConnector<OrangeKitSmartAccount, ConnectorProperties>(
    ({ chains, emitter }) => ({
      id,
      uid: id,
      name,
      type: "orangekit",
      icon,
      async setup() {
        // We can reinitialize the smart account on `switchChain`.
        orangeKitSmartAccount = await OrangeKitSmartAccount.init(
          initialChainId,
          rpcUrl,
          selectTransactionSender(initialChainId, relayApiKey, relayConfig),
        )
      },
      async connect({ chainId }: { chainId: number }) {
        try {
          if (!bitcoinWalletProvider.isInstalled()) {
            // Try to get the injected provider one more time, just in-case it
            // was missed during the lib initialization (e.g. because a wallet
            // was not yet available at that time).
            const provider = getWalletInjectedProvider(id)
            bitcoinWalletProvider.setProvider(provider!)

            if (!bitcoinWalletProvider.isInstalled()) {
              throw new Error(`${name} wallet is not installed`)
            }
          }
          // Ask for permission.
          const isChainSupported = chains.some((chain) => chain.id === chainId)
          const providerChainId = await this.getChainId()

          if (!isChainSupported || providerChainId !== chainId)
            throw new Error("Unsupported network ")

          await bitcoinWalletProvider.connect()

          const btcAddress = await bitcoinWalletProvider.getAddress()

          const doesBitcoinAddressNetworkMatchWithProviderChain =
            providerChainId === 1
              ? BitcoinAddressHelper.isMainnetAddress
              : BitcoinAddressHelper.isTestnetAddress

          if (
            btcAddress &&
            // We support Mezo Matsnet Testnet accounts for both BTC Mainnet and
            // BTC testnet chains, so we are ignoring this check in such case.
            providerChainId !== mezoMainnet.id &&
            providerChainId !== mezoTestnet.id &&
            !doesBitcoinAddressNetworkMatchWithProviderChain(btcAddress)
          ) {
            throw new WalletNetworkDoesNotMatchProviderChainError()
          }

          const accounts = await this.getAccounts()

          return {
            chainId: providerChainId,
            accounts,
          }
        } catch (err) {
          if (err instanceof Error) {
            const error = new BitcoinWalletConnectionError(name, err)

            emitter.emit("error", { error })
            throw error
          } else {
            throw new Error(
              "Something went wrong when trying to connect the wallet.",
              { cause: err },
            )
          }
        }
      },
      disconnect() {
        return bitcoinWalletProvider.disconnect()
      },
      async getAccounts() {
        const bitcoinAddress = await this.getBitcoinAddress()
        const publicKey = await bitcoinWalletProvider.getPublicKey()

        const ethAddress = await orangeKitSmartAccount.predictAddress(
          bitcoinAddress,
          publicKey,
        )

        return [getAddress(ethAddress)]
      },
      async getProvider(parameters?: { chainId?: number }) {
        let selectedChainId = initialChainId

        if (
          orangeKitSmartAccount &&
          orangeKitSmartAccount.chainId !== selectedChainId
        ) {
          selectedChainId = orangeKitSmartAccount.chainId
        }

        if (parameters && "chainId" in parameters && parameters.chainId) {
          selectedChainId = parameters.chainId
        }

        const selectedChain = chains.find(
          (chain) => chain.id === selectedChainId,
        )
        if (!selectedChain)
          throw new Error(
            `[getProvider] Chain id [${selectedChainId}] is not supported.`,
          )

        // TODO: What should we return here? We have custom client for this
        // connector so the custom client will be always used as provider in
        // wagmi.
        if (
          !orangeKitSmartAccount ||
          selectedChain.id !== orangeKitSmartAccount.chainId
        ) {
          orangeKitSmartAccount = await OrangeKitSmartAccount.init(
            selectedChain.id,
            selectedChain.id !== initialChainId
              ? selectedChain.rpcUrls.default.http[0]
              : rpcUrl,
            selectTransactionSender(selectedChainId, relayApiKey, relayConfig),
          )
        }

        return Promise.resolve(orangeKitSmartAccount)
      },
      async getChainId() {
        const provider = await this.getProvider()

        return normalizeChainId(provider.chainId)
      },
      async isAuthorized() {
        if (!bitcoinWalletProvider.isInstalled()) return false
        try {
          const account = await bitcoinWalletProvider?.getAddress()

          return !!account
        } catch (error) {
          return false
        }
      },
      async getClient(parameters) {
        const chainId = parameters?.chainId ?? (await this.getChainId())
        const [account] = await this.getAccounts()

        const chain = chains.find((c) => c.id === chainId)
        if (!chain)
          throw new Error(`[getClient] Chain id [${chainId}] is not supported.`)

        return createOrangeKitClient({
          chainId,
          bitcoinWalletProvider,
          rpcUrl:
            chainId !== initialChainId ? chain.rpcUrls.default.http[0] : rpcUrl,
          address: account,
          orangeKitSmartAccount,
        })
      },
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onAccountsChanged(accounts) {},
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onChainChanged(chainId) {},
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onConnect(connectInfo) {},
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onDisconnect(error) {},
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onMessage(message) {},
      getBitcoinAddress() {
        return bitcoinWalletProvider.getAddress()
      },
      getBitcoinProvider() {
        return bitcoinWalletProvider
      },
      async switchChain(parameters) {
        const chain = chains.find((c) => c.id === parameters.chainId)
        if (!chain)
          throw new Error(
            `[switchChain] Chain id [${parameters.chainId}] is not supported.`,
          )

        orangeKitSmartAccount = await OrangeKitSmartAccount.init(
          chain.id,
          chain.id !== initialChainId ? chain.rpcUrls.default.http[0] : rpcUrl,
          selectTransactionSender(chain.id, relayApiKey),
        )

        await this.connect({ chainId: chain.id })

        emitter.emit("change", {
          chainId: chain.id,
        })

        return chain
      },
    }),
  )
}
