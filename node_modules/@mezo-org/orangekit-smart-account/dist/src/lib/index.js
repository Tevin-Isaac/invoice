import { ethers, } from "ethers";
import { calculateSafeTransactionHash } from "@safe-global/protocol-kit/dist/src/utils";
import { Safe__factory } from "@mezo-org/orangekit-contracts/typechain";
import { getEthereumContracts, getSafeOwner } from "./ethereum";
import { BitcoinAddressHelper } from "./bitcoin";
import normalizeSafeSignature from "./utils/normalizeSafeSignature";
import MezoTransactionSender from "./utils/MezoTransactionSender";
export * from "./bitcoin";
const SAFE_VERSION = "1.4.1";
// eslint-disable-next-line import/prefer-default-export
export class OrangeKitSmartAccount {
    static async init(chainId, rpcUrl, transactionSender) {
        const provider = new ethers.JsonRpcProvider(rpcUrl);
        const contracts = getEthereumContracts(provider, chainId);
        return Promise.resolve(new OrangeKitSmartAccount(provider, chainId, contracts, transactionSender));
    }
    #chainId;
    #contracts;
    #provider;
    #transactionSender;
    constructor(provider, _chainId, contracts, transactionSender) {
        // TODO: chain validation
        this.#chainId = _chainId;
        // TODO: initialize contracts
        this.#contracts = contracts;
        this.#provider = provider;
        this.#transactionSender = transactionSender;
    }
    get chainId() {
        return this.#chainId;
    }
    get provider() {
        return this.#provider;
    }
    /**
     * Predicts the Ethereum address of a safe for a given Bitcoin address.
     * @param {string} bitcoinAddress - The Bitcoin address to predict the safe for.
     * @param {string} [publicKey] - The public key associated with the Bitcoin address.
     * @returns {Promise<Hex>} A promise that resolves to the predicted Ethereum address of the safe.
     */
    async predictAddress(bitcoinAddress, publicKey) {
        const truncatedBitcoinAddress = BitcoinAddressHelper.recoverTruncatedBitcoinAddress(bitcoinAddress, publicKey);
        const ethereumAddress = await this.#contracts.safeFactory.predictAddress(truncatedBitcoinAddress);
        return ethereumAddress;
    }
    async checkIfContractExists(address) {
        const existingCode = await this.#provider.getCode(address);
        return existingCode !== "0x";
    }
    async checkIfSafeExists(bitcoinAddress, publicKey) {
        const ethereumAddress = await this.predictAddress(bitcoinAddress, publicKey);
        return this.checkIfContractExists(ethereumAddress);
    }
    /**
     * Populates a transaction to deploy a safe for a given Bitcoin address.
     * @param {string} bitcoinAddress - The Bitcoin address to deploy the safe for.
     * @param {string} [publicKey] - The public key associated with the Bitcoin address.
     * @returns {Promise<ContractTransaction>} A promise that resolves to the populated transaction.
     */
    async populateSafeDeploymentTransaction(bitcoinAddress, publicKey) {
        const truncatedBitcoinAddress = BitcoinAddressHelper.recoverTruncatedBitcoinAddress(bitcoinAddress, publicKey);
        return this.#contracts.safeFactory.populateSafeDeploymentTransaction(truncatedBitcoinAddress);
    }
    /*
     * Deploys a safe corresponding to the given bitcoinAddress.  Note that this function is currently only used for
     * demonstrating integration testing capabilities.
     */
    async deploySafe(bitcoinAddress, relayerPrivateKey, rpcUrl) {
        // TODO: This will fail for the nested segwit case, we need to extract and
        //       pass the public key as well.
        const unsignedTx = await this.populateSafeDeploymentTransaction(bitcoinAddress);
        const signer = new ethers.Wallet(relayerPrivateKey, ethers.getDefaultProvider(rpcUrl));
        // Preflight check to prevent burning gas on failed transactions.
        await signer.estimateGas(unsignedTx);
        return signer.sendTransaction(unsignedTx);
    }
    // Check if a contract is already deployed at the given address and deploy it if not.
    // Returns the address with a transactionHash if the contract needed to be deployed.
    // Otherwise, returns just the address.
    async ensureContract(address, deploymentTransactionData) {
        const existingCode = await this.#provider.getCode(address);
        if (existingCode === "0x") {
            let result;
            if (this.#transactionSender.refundReceiver) {
                const transactionSender = new MezoTransactionSender("https://test.mezo.org/api/v2/relay/deploy-safe", this.#transactionSender.refundReceiver);
                result = await transactionSender.sendTransaction({
                    ...deploymentTransactionData,
                    chainId: this.#chainId,
                });
            }
            else {
                result = await this.#transactionSender.sendTransaction({
                    ...deploymentTransactionData,
                    chainId: this.#chainId,
                });
            }
            return { address, transactionHash: result.hash };
        }
        return { address };
    }
    async ensureSafeForBtcWallet(bitcoinAddress, publicKey) {
        const deploymentTransactionData = await this.populateSafeDeploymentTransaction(bitcoinAddress, publicKey);
        const predictedAddress = await this.predictAddress(bitcoinAddress, publicKey);
        await this.ensureContract(predictedAddress, deploymentTransactionData);
        const safe = Safe__factory.connect(predictedAddress, this.#provider);
        const owner = (await safe.getOwners())[0];
        const safeOwner = getSafeOwner(owner);
        return { safe, safeOwner };
    }
    /**
     * Sends a transaction from a safe associated with a given Bitcoin address.
     * @param {string} to - The Ethereum address to send the transaction to.
     * @param {string} value - The amount of Ether to send.
     * @param {string} data - The data to include in the transaction.
     * @param {string} bitcoinAddress - The Bitcoin address associated with the safe.
     * @param {string} publicKey - The public key associated with the Bitcoin address.
     * @param {BitcoinSignSafeTransactionMessageFn} bitcoinSignMessageFn - A
     * function to sign a message with the Bitcoin private key.
     * @returns {Promise<string>} A promise that resolves to the hash of the sent transaction.
     */
    async sendTransaction(to, value, data, bitcoinAddress, publicKey, bitcoinSignMessageFn) {
        const { safe, safeOwner } = await this.ensureSafeForBtcWallet(bitcoinAddress, publicKey);
        const safeAddress = await safe.getAddress();
        const nonce = Number(await safe.nonce());
        // If the transaction sender specifies a refund receiver, we estimate the
        // gas costs of the transaction, add a base gas that is enough to verify
        // the base Bitcoin transaction signature, and use the estimated gas price
        // from the provider. Note that the use of gas estimation implies that the
        // `from` address must have enough native token balance to pay for the
        // transaction execution.
        //
        // If no receiver is specified, we don't use refunds.
        const gasParameters = "refundReceiver" in this.#transactionSender &&
            this.#transactionSender.refundReceiver
            ? {
                safeTxGas: "0x3035F",
                baseGas: "0x3035F",
                gasPrice: (await this.#provider.getFeeData()).gasPrice?.toString() || "0",
                gasToken: ethers.ZeroAddress, // Refund in the base asset.
                refundReceiver: this.#transactionSender.refundReceiver,
            }
            : {
                safeTxGas: "0x0",
                baseGas: "0x0",
                gasPrice: "0x0",
                gasToken: ethers.ZeroAddress,
                refundReceiver: ethers.ZeroAddress,
            };
        const safeTx = {
            to,
            value,
            data,
            operation: 0,
            ...gasParameters,
            nonce,
        };
        // Calculate entry for the first signature slot as per how Safe handles
        // ERC-1271 signatures:
        // For ERC-1271 signature type is 0 and the signature is assembled as:
        // {32-bytes signature verifier}{32-bytes data position}{1-byte signature type}
        //
        // Reference:
        // https://docs.safe.global/advanced/smart-account-signatures#contract-signature-eip-1271
        const safeERC1271ConstantSignature = ethers.AbiCoder.defaultAbiCoder().encode(["address", "uint256", "uint8"], [await safeOwner.getAddress(), 65, 0]);
        const safeTxHash = calculateSafeTransactionHash(safeAddress, safeTx, SAFE_VERSION, (await this.#provider.getNetwork()).chainId);
        const signature = await bitcoinSignMessageFn(safeTxHash.slice(2), // drop the leading 0x
        safeTx);
        const safeBitcoinMessageSignature = await normalizeSafeSignature(signature, publicKey);
        const safeTxWithBitcoinSignature = await safe.execTransaction.populateTransaction(safeTx.to, safeTx.value, safeTx.data, safeTx.operation, safeTx.safeTxGas, safeTx.baseGas, safeTx.gasPrice, safeTx.gasToken, safeTx.refundReceiver, safeERC1271ConstantSignature + safeBitcoinMessageSignature);
        return (await this.#transactionSender.sendTransaction({
            ...safeTxWithBitcoinSignature,
            chainId: (await this.#provider.getNetwork()).chainId,
        })).hash;
    }
}
//# sourceMappingURL=index.js.map