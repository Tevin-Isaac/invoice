import {
  ContractTransaction,
  ethers,
  Provider,
  TransactionResponse,
} from "ethers"
import { calculateSafeTransactionHash } from "@safe-global/protocol-kit/dist/src/utils"
import { Safe__factory } from "@mezo-org/orangekit-contracts/typechain"
import { getEthereumContracts, getSafeOwner, SafeWithOwner } from "./ethereum"
import { OrangeKitContracts } from "./contracts"
import { BitcoinAddressHelper } from "./bitcoin"
import { Hex } from "./utils"

import normalizeSafeSignature from "./utils/normalizeSafeSignature"
import { TransactionSender } from "./utils/TransactionSender"
import MezoTransactionSender from "./utils/MezoTransactionSender"

export * from "./bitcoin"

const SAFE_VERSION = "1.4.1"

type EnsureContractResult = {
  address: string
  transactionHash?: string
}

/**
 *  Represents the Safe transaction data payload for calculating the hash used
 *  as a message to sign with Bitcoin wallet.
 */
export type SafeTransactionData = {
  /**
   * Destination address of Safe transaction.
   */
  to: string
  /**
   * The amount of ether (in wei) of Safe transaction.
   */
  value: string
  /**
   * Data payload of Safe transaction.
   */
  data: string
  /**
   * Operation type of Safe transaction.
   */
  operation: number
  /**
   * Gas that should be used for the Safe transaction.
   */
  safeTxGas: string
  /**
   * Gas costs for that are independent of the transaction execution(e.g. base
   * transaction fee, signature check, payment of the refund)
   */
  baseGas: string
  /**
   * Gas price that should be used for the payment calculation.
   */
  gasPrice: string
  /**
   * Token address (or 0 if ETH) that is used for the payment.
   */
  gasToken: string
  /**
   * Address of receiver of gas payment (or 0 if tx.origin).
   */
  refundReceiver: string
  /**
   * Transaction nonce.
   */
  nonce: number
}

/**
 * Function for signing a Bitcoin transaction message. The message is a hash of
 * the Safe transaction with details specified by the `transactionData`.
 * Handling the `transactionData` is optional and can be used to provide the
 * clear signing process, depending on the wallet implementation.
 *
 * @param message - Message to sign.
 * @param transactionData - Safe transaction data serves as the payload for the
 *        message to sign calculation.
 *
 * @returns A promise that resolves to a string representing the signed message.
 */
export type BitcoinSignSafeTransactionMessageFn = (
  message: string,
  transactionData: SafeTransactionData,
) => Promise<string>

// eslint-disable-next-line import/prefer-default-export
export class OrangeKitSmartAccount {
  static async init(
    chainId: number,
    rpcUrl: string,
    transactionSender: TransactionSender,
  ) {
    const provider = new ethers.JsonRpcProvider(rpcUrl)
    const contracts = getEthereumContracts(provider, chainId)

    return Promise.resolve(
      new OrangeKitSmartAccount(
        provider,
        chainId,
        contracts,
        transactionSender,
      ),
    )
  }

  #chainId: number

  #contracts: OrangeKitContracts

  #provider: Provider

  #transactionSender: TransactionSender

  constructor(
    provider: Provider,
    _chainId: number,
    contracts: OrangeKitContracts,
    transactionSender: TransactionSender,
  ) {
    // TODO: chain validation
    this.#chainId = _chainId
    // TODO: initialize contracts
    this.#contracts = contracts

    this.#provider = provider

    this.#transactionSender = transactionSender
  }

  get chainId(): number {
    return this.#chainId
  }

  get provider(): Provider {
    return this.#provider
  }

  /**
   * Predicts the Ethereum address of a safe for a given Bitcoin address.
   * @param {string} bitcoinAddress - The Bitcoin address to predict the safe for.
   * @param {string} [publicKey] - The public key associated with the Bitcoin address.
   * @returns {Promise<Hex>} A promise that resolves to the predicted Ethereum address of the safe.
   */
  async predictAddress(
    bitcoinAddress: string,
    publicKey?: string,
  ): Promise<Hex> {
    const truncatedBitcoinAddress =
      BitcoinAddressHelper.recoverTruncatedBitcoinAddress(
        bitcoinAddress,
        publicKey,
      )

    const ethereumAddress = await this.#contracts.safeFactory.predictAddress(
      truncatedBitcoinAddress,
    )

    return ethereumAddress
  }

  private async checkIfContractExists(address: string): Promise<boolean> {
    const existingCode = await this.#provider.getCode(address)
    return existingCode !== "0x"
  }

  async checkIfSafeExists(
    bitcoinAddress: string,
    publicKey?: string,
  ): Promise<boolean> {
    const ethereumAddress = await this.predictAddress(bitcoinAddress, publicKey)
    return this.checkIfContractExists(ethereumAddress)
  }

  /**
   * Populates a transaction to deploy a safe for a given Bitcoin address.
   * @param {string} bitcoinAddress - The Bitcoin address to deploy the safe for.
   * @param {string} [publicKey] - The public key associated with the Bitcoin address.
   * @returns {Promise<ContractTransaction>} A promise that resolves to the populated transaction.
   */
  async populateSafeDeploymentTransaction(
    bitcoinAddress: string,
    publicKey?: string,
  ): Promise<ContractTransaction> {
    const truncatedBitcoinAddress =
      BitcoinAddressHelper.recoverTruncatedBitcoinAddress(
        bitcoinAddress,
        publicKey,
      )

    return this.#contracts.safeFactory.populateSafeDeploymentTransaction(
      truncatedBitcoinAddress,
    )
  }

  /*
   * Deploys a safe corresponding to the given bitcoinAddress.  Note that this function is currently only used for
   * demonstrating integration testing capabilities.
   */
  async deploySafe(
    bitcoinAddress: string,
    relayerPrivateKey: string,
    rpcUrl: string,
  ): Promise<TransactionResponse> {
    // TODO: This will fail for the nested segwit case, we need to extract and
    //       pass the public key as well.
    const unsignedTx =
      await this.populateSafeDeploymentTransaction(bitcoinAddress)

    const signer = new ethers.Wallet(
      relayerPrivateKey,
      ethers.getDefaultProvider(rpcUrl),
    )

    // Preflight check to prevent burning gas on failed transactions.
    await signer.estimateGas(unsignedTx)

    return signer.sendTransaction(unsignedTx)
  }

  // Check if a contract is already deployed at the given address and deploy it if not.
  // Returns the address with a transactionHash if the contract needed to be deployed.
  // Otherwise, returns just the address.
  private async ensureContract(
    address: string,
    deploymentTransactionData: ContractTransaction,
  ): Promise<EnsureContractResult> {
    const existingCode = await this.#provider.getCode(address)
    if (existingCode === "0x") {
      let result
      if (this.#transactionSender.refundReceiver) {
        const transactionSender = new MezoTransactionSender(
          "https://test.mezo.org/api/v2/relay/deploy-safe",
          this.#transactionSender.refundReceiver,
        )

        result = await transactionSender.sendTransaction({
          ...deploymentTransactionData,
          chainId: this.#chainId,
        })
      } else {
        result = await this.#transactionSender.sendTransaction({
          ...deploymentTransactionData,
          chainId: this.#chainId,
        })
      }

      return { address, transactionHash: result.hash }
    }

    return { address }
  }

  private async ensureSafeForBtcWallet(
    bitcoinAddress: string,
    publicKey?: string,
  ): Promise<SafeWithOwner> {
    const deploymentTransactionData =
      await this.populateSafeDeploymentTransaction(bitcoinAddress, publicKey)
    const predictedAddress = await this.predictAddress(
      bitcoinAddress,
      publicKey,
    )
    await this.ensureContract(predictedAddress, deploymentTransactionData)
    const safe = Safe__factory.connect(predictedAddress, this.#provider)
    const owner = (await safe.getOwners())[0]
    const safeOwner = getSafeOwner(owner)
    return { safe, safeOwner }
  }

  /**
   * Sends a transaction from a safe associated with a given Bitcoin address.
   * @param {string} to - The Ethereum address to send the transaction to.
   * @param {string} value - The amount of Ether to send.
   * @param {string} data - The data to include in the transaction.
   * @param {string} bitcoinAddress - The Bitcoin address associated with the safe.
   * @param {string} publicKey - The public key associated with the Bitcoin address.
   * @param {BitcoinSignSafeTransactionMessageFn} bitcoinSignMessageFn - A
   * function to sign a message with the Bitcoin private key.
   * @returns {Promise<string>} A promise that resolves to the hash of the sent transaction.
   */
  async sendTransaction(
    to: string,
    value: string,
    data: string,
    bitcoinAddress: string,
    publicKey: string,
    bitcoinSignMessageFn: BitcoinSignSafeTransactionMessageFn,
  ): Promise<string> {
    const { safe, safeOwner } = await this.ensureSafeForBtcWallet(
      bitcoinAddress,
      publicKey,
    )
    const safeAddress = await safe.getAddress()

    const nonce = Number(await safe.nonce())

    // If the transaction sender specifies a refund receiver, we estimate the
    // gas costs of the transaction, add a base gas that is enough to verify
    // the base Bitcoin transaction signature, and use the estimated gas price
    // from the provider. Note that the use of gas estimation implies that the
    // `from` address must have enough native token balance to pay for the
    // transaction execution.
    //
    // If no receiver is specified, we don't use refunds.
    const gasParameters =
      "refundReceiver" in this.#transactionSender &&
      this.#transactionSender.refundReceiver
        ? {
            safeTxGas: "0x3035F",
            baseGas: "0x3035F",
            gasPrice:
              (await this.#provider.getFeeData()).gasPrice?.toString() || "0",
            gasToken: ethers.ZeroAddress, // Refund in the base asset.
            refundReceiver: this.#transactionSender.refundReceiver,
          }
        : {
            safeTxGas: "0x0",
            baseGas: "0x0",
            gasPrice: "0x0",
            gasToken: ethers.ZeroAddress,
            refundReceiver: ethers.ZeroAddress,
          }

    const safeTx = {
      to,
      value,
      data,
      operation: 0,
      ...gasParameters,
      nonce,
    }

    // Calculate entry for the first signature slot as per how Safe handles
    // ERC-1271 signatures:
    // For ERC-1271 signature type is 0 and the signature is assembled as:
    // {32-bytes signature verifier}{32-bytes data position}{1-byte signature type}
    //
    // Reference:
    // https://docs.safe.global/advanced/smart-account-signatures#contract-signature-eip-1271
    const safeERC1271ConstantSignature =
      ethers.AbiCoder.defaultAbiCoder().encode(
        ["address", "uint256", "uint8"],
        [await safeOwner.getAddress(), 65, 0],
      )

    const safeTxHash = calculateSafeTransactionHash(
      safeAddress,
      safeTx,
      SAFE_VERSION,
      (await this.#provider.getNetwork()).chainId,
    )

    const signature = await bitcoinSignMessageFn(
      safeTxHash.slice(2), // drop the leading 0x
      safeTx,
    )
    const safeBitcoinMessageSignature = await normalizeSafeSignature(
      signature,
      publicKey,
    )

    const safeTxWithBitcoinSignature =
      await safe.execTransaction.populateTransaction(
        safeTx.to,
        safeTx.value,
        safeTx.data,
        safeTx.operation,
        safeTx.safeTxGas,
        safeTx.baseGas,
        safeTx.gasPrice,
        safeTx.gasToken,
        safeTx.refundReceiver,
        safeERC1271ConstantSignature + safeBitcoinMessageSignature,
      )

    return (
      await this.#transactionSender.sendTransaction({
        ...safeTxWithBitcoinSignature,
        chainId: (await this.#provider.getNetwork()).chainId,
      })
    ).hash
  }
}
