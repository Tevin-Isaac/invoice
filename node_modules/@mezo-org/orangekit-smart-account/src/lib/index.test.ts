import { mock, MockProxy } from "jest-mock-extended"
import { Provider } from "ethers"
import { OrangeKitSmartAccount } from "./index"
import { OrangeKitContracts } from "./contracts"
import { LocalTransactionSender } from ".."

let orangekitSmartAccount: OrangeKitSmartAccount
let provider: MockProxy<Provider> & Provider
let contracts: MockProxy<OrangeKitContracts> & OrangeKitContracts

describe("OrangeKitSmartAccount", () => {
  beforeEach(() => {
    provider = mock<Provider>()
    contracts = mock<OrangeKitContracts>()
    const transactionSender = mock<LocalTransactionSender>()
    orangekitSmartAccount = new OrangeKitSmartAccount(
      provider,
      1,
      contracts,
      transactionSender,
    )
  })
  describe("checkIfSafeExists", () => {
    it("checks safe existence correctly when safe exists", async () => {
      const bitcoinAddress = "bitcoinAddress"
      const publicKey = "publicKey"
      const ethereumAddress = "0x123"
      jest
        .spyOn(orangekitSmartAccount, "predictAddress")
        .mockResolvedValue(ethereumAddress)
      provider.getCode.mockResolvedValue("0x456")

      const result = await orangekitSmartAccount.checkIfSafeExists(
        bitcoinAddress,
        publicKey,
      )

      expect(result).toBe(true)
    })

    it("checks safe existence correctly when safe does not exist", async () => {
      const bitcoinAddress = "bitcoinAddress"
      const publicKey = "publicKey"
      const ethereumAddress = "0x123"
      jest
        .spyOn(orangekitSmartAccount, "predictAddress")
        .mockResolvedValue(ethereumAddress)
      provider.getCode.mockResolvedValue("0x")

      const result = await orangekitSmartAccount.checkIfSafeExists(
        bitcoinAddress,
        publicKey,
      )

      expect(result).toBe(false)
    })
  })
})
