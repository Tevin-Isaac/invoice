import { mock, MockProxy } from "jest-mock-extended"
import { PublicClient } from "viem"
import { OrangeKitSmartAccount } from "./index"
import { OrangeKitContracts } from "./contracts"
import { LocalTransactionSender } from ".."
import { predictAddressTestData } from "./utils/predictOrangeKitAddress.test"

let orangekitSmartAccount: OrangeKitSmartAccount
let client: MockProxy<PublicClient> & PublicClient
let contracts: MockProxy<OrangeKitContracts> & OrangeKitContracts

describe("OrangeKitSmartAccount", () => {
  beforeEach(() => {
    client = mock<PublicClient>()
    contracts = mock<OrangeKitContracts>()
    const transactionSender = mock<LocalTransactionSender>()
    orangekitSmartAccount = new OrangeKitSmartAccount(
      client,
      1,
      contracts,
      transactionSender,
    )
  })
  describe("checkIfSafeExists", () => {
    it("checks safe existence correctly when safe exists", async () => {
      const bitcoinAddress = "bitcoinAddress"
      const publicKey = "publicKey"
      const ethereumAddress = "0x123"
      jest
        .spyOn(orangekitSmartAccount, "predictAddress")
        .mockResolvedValue(ethereumAddress)
      client.getCode.mockResolvedValue("0x456")

      const result = await orangekitSmartAccount.checkIfSafeExists(
        bitcoinAddress,
        publicKey,
      )

      expect(result).toBe(true)
    })

    it("checks safe existence correctly when safe does not exist", async () => {
      const bitcoinAddress = "bitcoinAddress"
      const publicKey = "publicKey"
      const ethereumAddress = "0x123"
      jest
        .spyOn(orangekitSmartAccount, "predictAddress")
        .mockResolvedValue(ethereumAddress)
      client.getCode.mockResolvedValue(undefined)

      const result = await orangekitSmartAccount.checkIfSafeExists(
        bitcoinAddress,
        publicKey,
      )

      expect(result).toBe(false)
    })
  })

  describe("predictAddress", () => {
    describe("with Bitcoin address input", () => {
      it.each(predictAddressTestData.passTestDataWithBitcoinAddressInput)(
        "should predict address for input of $description",
        async ({ input, output }) => {
          const result = await orangekitSmartAccount.predictAddress(...input)

          expect(result).toBe(output)
        },
      )

      it.each(predictAddressTestData.failTestDataWithBitcoinAddressInput)(
        "should throw error for input of $description",
        ({ input, output }) => {
          const fn = () => orangekitSmartAccount.predictAddress(...input)

          expect(fn).rejects.toThrow(output)
        },
      )
    })
  })
})
